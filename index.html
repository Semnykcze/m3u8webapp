<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Image Processor - Depth Maps & Edge Detection</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opencv@7.0.0/lib/opencv.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#8b5cf6'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <h1 class="text-xl font-bold text-gray-900 dark:text-white">
                        üñºÔ∏è AI Image Processor
                    </h1>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="darkModeToggle" class="p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                        <span class="dark:hidden">üåô</span>
                        <span class="hidden dark:inline">‚òÄÔ∏è</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Panel - Controls -->
            <div class="lg:col-span-1">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
                    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-6">Controls</h2>
                    
                    <!-- Image Upload -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Upload Image
                        </label>
                        <div id="dropZone" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-primary transition-colors cursor-pointer">
                            <input type="file" id="imageInput" accept="image/*" class="hidden">
                            <div id="dropText">
                                <p class="text-gray-500 dark:text-gray-400">Drop an image here or click to select</p>
                                <p class="text-sm text-gray-400 dark:text-gray-500 mt-1">Supports JPG, PNG, WebP</p>
                            </div>
                        </div>
                    </div>

                    <!-- Webcam Controls -->
                    <div class="mb-6">
                        <div class="flex items-center justify-between mb-2">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Webcam Input</label>
                            <button id="webcamToggle" class="px-3 py-1 text-xs bg-secondary text-white rounded-md hover:bg-purple-600 transition-colors">
                                Start Webcam
                            </button>
                        </div>
                        <video id="webcamVideo" class="w-full rounded-lg hidden" autoplay playsinline></video>
                        <button id="captureBtn" class="w-full mt-2 px-4 py-2 bg-primary text-white rounded-md hover:bg-blue-600 transition-colors hidden">
                            Capture Frame
                        </button>
                    </div>

                    <!-- Processing Mode -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Processing Mode
                        </label>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="radio" name="mode" value="depth" class="text-primary" checked>
                                <span class="ml-2 text-sm text-gray-700 dark:text-gray-300">Depth Map</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="mode" value="canny" class="text-primary">
                                <span class="ml-2 text-sm text-gray-700 dark:text-gray-300">Canny Edges</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="mode" value="overlay" class="text-primary">
                                <span class="ml-2 text-sm text-gray-700 dark:text-gray-300">Overlay</span>
                            </label>
                        </div>
                    </div>

                    <!-- Depth Map Settings -->
                    <div id="depthSettings" class="mb-6">
                        <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Depth Map Settings</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">Colormap</label>
                                <select id="colormapSelect" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white">
                                    <option value="grayscale">Grayscale</option>
                                    <option value="inferno">Inferno</option>
                                    <option value="turbo">Turbo</option>
                                    <option value="plasma">Plasma</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Canny Settings -->
                    <div id="cannySettings" class="mb-6 hidden">
                        <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Canny Edge Settings</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">
                                    Low Threshold: <span id="lowThresholdValue">50</span>
                                </label>
                                <input type="range" id="lowThreshold" min="0" max="255" value="50" class="w-full">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">
                                    High Threshold: <span id="highThresholdValue">150</span>
                                </label>
                                <input type="range" id="highThreshold" min="0" max="255" value="150" class="w-full">
                            </div>
                        </div>
                    </div>

                    <!-- Process Button -->
                    <div class="mb-6">
                        <button id="processBtn" class="w-full px-4 py-3 bg-primary text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Process Image
                        </button>
                    </div>

                    <!-- Performance Stats -->
                    <div id="perfStats" class="mb-6 hidden">
                        <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Performance</h3>
                        <div class="text-xs text-gray-600 dark:text-gray-400 space-y-1">
                            <div>Inference Time: <span id="inferenceTime">-</span>ms</div>
                            <div>Total Time: <span id="totalTime">-</span>ms</div>
                        </div>
                    </div>

                    <!-- Export Controls -->
                    <div class="space-y-2">
                        <button id="downloadBtn" class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors disabled:opacity-50" disabled>
                            Download Result
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Results -->
            <div class="lg:col-span-2">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
                    <!-- Tabs -->
                    <div class="flex space-x-1 mb-6 bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
                        <button class="tab-btn active px-4 py-2 text-sm font-medium rounded-md transition-colors" data-tab="original">
                            Original
                        </button>
                        <button class="tab-btn px-4 py-2 text-sm font-medium rounded-md transition-colors" data-tab="depth">
                            Depth Map
                        </button>
                        <button class="tab-btn px-4 py-2 text-sm font-medium rounded-md transition-colors" data-tab="edges">
                            Canny Edges
                        </button>
                        <button class="tab-btn px-4 py-2 text-sm font-medium rounded-md transition-colors" data-tab="overlay">
                            Overlay
                        </button>
                    </div>

                    <!-- Canvas Container -->
                    <div class="relative bg-gray-50 dark:bg-gray-900 rounded-lg p-4 min-h-96 flex items-center justify-center">
                        <div id="loadingSpinner" class="hidden">
                            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">Processing...</p>
                        </div>
                        
                        <div id="canvasContainer" class="hidden">
                            <canvas id="originalCanvas" class="max-w-full max-h-96 rounded-lg shadow-sm"></canvas>
                            <canvas id="depthCanvas" class="max-w-full max-h-96 rounded-lg shadow-sm hidden"></canvas>
                            <canvas id="edgesCanvas" class="max-w-full max-h-96 rounded-lg shadow-sm hidden"></canvas>
                            <canvas id="overlayCanvas" class="max-w-full max-h-96 rounded-lg shadow-sm hidden"></canvas>
                        </div>

                        <div id="placeholderText" class="text-center text-gray-500 dark:text-gray-400">
                            <p class="text-lg mb-2">Upload an image to get started</p>
                            <p class="text-sm">Supports depth estimation and edge detection</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Global variables
        let currentImage = null;
        let depthModel = null;
        let isWebcamActive = false;
        let webcamStream = null;
        
        // DOM elements
        const elements = {
            imageInput: document.getElementById('imageInput'),
            dropZone: document.getElementById('dropZone'),
            webcamVideo: document.getElementById('webcamVideo'),
            webcamToggle: document.getElementById('webcamToggle'),
            captureBtn: document.getElementById('captureBtn'),
            processBtn: document.getElementById('processBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            darkModeToggle: document.getElementById('darkModeToggle'),
            
            // Settings
            colormapSelect: document.getElementById('colormapSelect'),
            lowThreshold: document.getElementById('lowThreshold'),
            highThreshold: document.getElementById('highThreshold'),
            lowThresholdValue: document.getElementById('lowThresholdValue'),
            highThresholdValue: document.getElementById('highThresholdValue'),
            
            // Canvas elements
            originalCanvas: document.getElementById('originalCanvas'),
            depthCanvas: document.getElementById('depthCanvas'),
            edgesCanvas: document.getElementById('edgesCanvas'),
            overlayCanvas: document.getElementById('overlayCanvas'),
            
            // UI states
            loadingSpinner: document.getElementById('loadingSpinner'),
            canvasContainer: document.getElementById('canvasContainer'),
            placeholderText: document.getElementById('placeholderText'),
            perfStats: document.getElementById('perfStats'),
            inferenceTime: document.getElementById('inferenceTime'),
            totalTime: document.getElementById('totalTime'),
            
            // Settings panels
            depthSettings: document.getElementById('depthSettings'),
            cannySettings: document.getElementById('cannySettings')
        };

        // Utility functions
        class ImageProcessor {
            static async loadModel() {
                try {
                    // For demo purposes, we'll simulate model loading
                    // In a real implementation, you'd load an actual ONNX model
                    console.log('Model loading simulated - in production, load actual DPT/MiDaS model');
                    return true;
                } catch (error) {
                    console.error('Error loading model:', error);
                    return false;
                }
            }

            static preprocessImage(image, targetSize = 384) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Maintain aspect ratio while resizing
                const aspectRatio = image.width / image.height;
                let width, height;
                
                if (aspectRatio > 1) {
                    width = targetSize;
                    height = targetSize / aspectRatio;
                } else {
                    width = targetSize * aspectRatio;
                    height = targetSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                ctx.drawImage(image, 0, 0, width, height);
                return canvas;
            }

            static async runDepthModel(imageCanvas) {
                // Simulate depth model inference
                // In production, this would use actual ONNX model
                const startTime = performance.now();
                
                // Create simulated depth map
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageCanvas.width;
                canvas.height = imageCanvas.height;
                
                // Get image data for processing
                const imageData = imageCanvas.getContext('2d').getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const depthData = new ImageData(imageCanvas.width, imageCanvas.height);
                
                // Simulate depth estimation (simple gradient based on brightness)
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const gray = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                    const depth = 255 - gray; // Invert for depth-like appearance
                    
                    depthData.data[i] = depth;
                    depthData.data[i + 1] = depth;
                    depthData.data[i + 2] = depth;
                    depthData.data[i + 3] = 255;
                }
                
                ctx.putImageData(depthData, 0, 0);
                
                const inferenceTime = performance.now() - startTime;
                return { canvas, inferenceTime };
            }

            static applyCanny(imageCanvas, lowThreshold = 50, highThreshold = 150) {
                return new Promise((resolve) => {
                    try {
                        if (typeof cv === 'undefined') {
                            throw new Error('OpenCV.js not loaded');
                        }

                        const src = cv.imread(imageCanvas);
                        const gray = new cv.Mat();
                        const edges = new cv.Mat();
                        
                        // Convert to grayscale
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                        
                        // Apply Canny edge detection
                        cv.Canny(gray, edges, lowThreshold, highThreshold);
                        
                        // Convert back to RGBA for display
                        const result = new cv.Mat();
                        cv.cvtColor(edges, result, cv.COLOR_GRAY2RGBA);
                        
                        // Create output canvas
                        const outputCanvas = document.createElement('canvas');
                        cv.imshow(outputCanvas, result);
                        
                        // Clean up
                        src.delete();
                        gray.delete();
                        edges.delete();
                        result.delete();
                        
                        resolve(outputCanvas);
                    } catch (error) {
                        console.error('Canny edge detection error:', error);
                        // Fallback: create a simple edge detection
                        const fallbackCanvas = this.createFallbackEdges(imageCanvas, lowThreshold, highThreshold);
                        resolve(fallbackCanvas);
                    }
                });
            }

            static createFallbackEdges(imageCanvas, lowThreshold, highThreshold) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageCanvas.width;
                canvas.height = imageCanvas.height;
                
                const imageData = imageCanvas.getContext('2d').getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const edgeData = new ImageData(imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                const width = imageCanvas.width;
                
                // Simple Sobel edge detection
                for (let y = 1; y < imageCanvas.height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Get surrounding pixels
                        const tl = data[((y-1) * width + (x-1)) * 4];
                        const tm = data[((y-1) * width + x) * 4];
                        const tr = data[((y-1) * width + (x+1)) * 4];
                        const ml = data[(y * width + (x-1)) * 4];
                        const mr = data[(y * width + (x+1)) * 4];
                        const bl = data[((y+1) * width + (x-1)) * 4];
                        const bm = data[((y+1) * width + x) * 4];
                        const br = data[((y+1) * width + (x+1)) * 4];
                        
                        // Sobel operators
                        const gx = (-1 * tl) + (1 * tr) + (-2 * ml) + (2 * mr) + (-1 * bl) + (1 * br);
                        const gy = (-1 * tl) + (-2 * tm) + (-1 * tr) + (1 * bl) + (2 * bm) + (1 * br);
                        
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        const edge = magnitude > lowThreshold ? 255 : 0;
                        
                        edgeData.data[idx] = edge;
                        edgeData.data[idx + 1] = edge;
                        edgeData.data[idx + 2] = edge;
                        edgeData.data[idx + 3] = 255;
                    }
                }
                
                ctx.putImageData(edgeData, 0, 0);
                return canvas;
            }

            static applyColormap(canvas, colormapType) {
                if (colormapType === 'grayscale') return canvas;
                
                const outputCanvas = document.createElement('canvas');
                const ctx = outputCanvas.getContext('2d');
                outputCanvas.width = canvas.width;
                outputCanvas.height = canvas.height;
                
                const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                const coloredData = new ImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const gray = imageData.data[i]; // Assuming grayscale input
                    const normalized = gray / 255;
                    const color = this.getColormapColor(normalized, colormapType);
                    
                    coloredData.data[i] = color.r;
                    coloredData.data[i + 1] = color.g;
                    coloredData.data[i + 2] = color.b;
                    coloredData.data[i + 3] = 255;
                }
                
                ctx.putImageData(coloredData, 0, 0);
                return outputCanvas;
            }

            static getColormapColor(value, type) {
                switch (type) {
                    case 'inferno':
                        return this.infernoColormap(value);
                    case 'turbo':
                        return this.turboColormap(value);
                    case 'plasma':
                        return this.plasmaColormap(value);
                    default:
                        return { r: value * 255, g: value * 255, b: value * 255 };
                }
            }

            static infernoColormap(t) {
                t = Math.max(0, Math.min(1, t));
                const r = Math.min(255, Math.max(0, 255 * (0.0014 + 1.7204 * t - 0.4472 * t * t)));
                const g = Math.min(255, Math.max(0, 255 * (-0.0063 + 2.2931 * t - 1.2422 * t * t)));
                const b = Math.min(255, Math.max(0, 255 * (0.0074 + 0.9394 * t + 0.0526 * t * t)));
                return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
            }

            static turboColormap(t) {
                t = Math.max(0, Math.min(1, t));
                const r = Math.min(255, Math.max(0, 255 * (0.13 + 0.87 * t)));
                const g = Math.min(255, Math.max(0, 255 * (0.15 + 0.85 * t)));
                const b = Math.min(255, Math.max(0, 255 * (0.25 + 0.75 * (1 - t))));
                return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
            }

            static plasmaColormap(t) {
                t = Math.max(0, Math.min(1, t));
                const r = Math.min(255, Math.max(0, 255 * (0.05 + 0.95 * t)));
                const g = Math.min(255, Math.max(0, 255 * (0.03 + 0.97 * t * (1 - t))));
                const b = Math.min(255, Math.max(0, 255 * (0.53 + 0.47 * (1 - t))));
                return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
            }

            static createOverlay(depthCanvas, edgesCanvas) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = depthCanvas.width;
                canvas.height = depthCanvas.height;
                
                // Draw depth map first
                ctx.drawImage(depthCanvas, 0, 0);
                
                // Overlay edges with blend mode
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(edgesCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
                
                return canvas;
            }
        }

        // UI Management
        class UIManager {
            static init() {
                this.setupEventListeners();
                this.setupTabSwitching();
                this.loadDarkModePreference();
                this.updateModeSettings();
            }

            static setupEventListeners() {
                // File input
                elements.imageInput.addEventListener('change', this.handleFileSelect);
                elements.dropZone.addEventListener('click', () => elements.imageInput.click());
                elements.dropZone.addEventListener('dragover', this.handleDragOver);
                elements.dropZone.addEventListener('drop', this.handleDrop);

                // Webcam
                elements.webcamToggle.addEventListener('click', this.toggleWebcam);
                elements.captureBtn.addEventListener('click', this.captureWebcamFrame);

                // Processing
                elements.processBtn.addEventListener('click', this.processImage);
                elements.downloadBtn.addEventListener('click', this.downloadResult);

                // Settings
                elements.lowThreshold.addEventListener('input', this.updateThresholds);
                elements.highThreshold.addEventListener('input', this.updateThresholds);
                
                // Mode switching
                document.querySelectorAll('input[name="mode"]').forEach(radio => {
                    radio.addEventListener('change', this.updateModeSettings);
                });

                // Dark mode
                elements.darkModeToggle.addEventListener('click', this.toggleDarkMode);
            }

            static setupTabSwitching() {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tab = e.target.dataset.tab;
                        this.switchTab(tab);
                    });
                });
            }

            static switchTab(tab) {
                // Update tab buttons
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-white', 'dark:bg-gray-800', 'text-primary', 'shadow-sm');
                    btn.classList.add('text-gray-600', 'dark:text-gray-400', 'hover:text-gray-900', 'dark:hover:text-white');
                });
                
                const activeBtn = document.querySelector(`[data-tab="${tab}"]`);
                activeBtn.classList.add('active', 'bg-white', 'dark:bg-gray-800', 'text-primary', 'shadow-sm');
                activeBtn.classList.remove('text-gray-600', 'dark:text-gray-400', 'hover:text-gray-900', 'dark:hover:text-white');

                // Update canvas visibility
                document.querySelectorAll('#canvasContainer canvas').forEach(canvas => {
                    canvas.classList.add('hidden');
                });
                
                const targetCanvas = document.getElementById(`${tab}Canvas`);
                if (targetCanvas) {
                    targetCanvas.classList.remove('hidden');
                }
            }

            static handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    ImageLoader.loadFromFile(file);
                }
            }

            static handleDragOver(event) {
                event.preventDefault();
                elements.dropZone.classList.add('border-primary');
            }

            static handleDrop(event) {
                event.preventDefault();
                elements.dropZone.classList.remove('border-primary');
                
                const file = event.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    ImageLoader.loadFromFile(file);
                }
            }

            static async toggleWebcam() {
                if (!isWebcamActive) {
                    try {
                        webcamStream = await navigator.mediaDevices.getUserMedia({ 
                            video: { width: 640, height: 480 } 
                        });
                        elements.webcamVideo.srcObject = webcamStream;
                        elements.webcamVideo.classList.remove('hidden');
                        elements.captureBtn.classList.remove('hidden');
                        elements.webcamToggle.textContent = 'Stop Webcam';
                        isWebcamActive = true;
                    } catch (error) {
                        console.error('Error accessing webcam:', error);
                        alert('Could not access webcam. Please check permissions.');
                    }
                } else {
                    if (webcamStream) {
                        webcamStream.getTracks().forEach(track => track.stop());
                    }
                    elements.webcamVideo.classList.add('hidden');
                    elements.captureBtn.classList.add('hidden');
                    elements.webcamToggle.textContent = 'Start Webcam';
                    isWebcamActive = false;
                }
            }

            static captureWebcamFrame() {
                const video = elements.webcamVideo;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob(blob => {
                    ImageLoader.loadFromFile(blob);
                });
            }

            static updateThresholds() {
                elements.lowThresholdValue.textContent = elements.lowThreshold.value;
                elements.highThresholdValue.textContent = elements.highThreshold.value;
            }

            static updateModeSettings() {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                
                elements.depthSettings.classList.toggle('hidden', mode !== 'depth');
                elements.cannySettings.classList.toggle('hidden', mode !== 'canny' && mode !== 'overlay');
            }

            static async processImage() {
                if (!currentImage) return;

                const startTime = performance.now();
                this.showLoading(true);
                
                try {
                    const mode = document.querySelector('input[name="mode"]:checked').value;
                    const preprocessed = ImageProcessor.preprocessImage(currentImage);
                    
                    let result;
                    let inferenceTime = 0;
                    
                    if (mode === 'depth') {
                        const depthResult = await ImageProcessor.runDepthModel(preprocessed);
                        result = ImageProcessor.applyColormap(depthResult.canvas, elements.colormapSelect.value);
                        inferenceTime = depthResult.inferenceTime;
                        
                        this.renderCanvas(elements.depthCanvas, result);
                        this.switchTab('depth');
                        
                    } else if (mode === 'canny') {
                        result = await ImageProcessor.applyCanny(
                            preprocessed, 
                            parseInt(elements.lowThreshold.value),
                            parseInt(elements.highThreshold.value)
                        );
                        
                        this.renderCanvas(elements.edgesCanvas, result);
                        this.switchTab('edges');
                        
                    } else if (mode === 'overlay') {
                        const depthResult = await ImageProcessor.runDepthModel(preprocessed);
                        const depthCanvas = ImageProcessor.applyColormap(depthResult.canvas, elements.colormapSelect.value);
                        const edgesCanvas = await ImageProcessor.applyCanny(
                            preprocessed,
                            parseInt(elements.lowThreshold.value),
                            parseInt(elements.highThreshold.value)
                        );
                        
                        result = ImageProcessor.createOverlay(depthCanvas, edgesCanvas);
                        inferenceTime = depthResult.inferenceTime;
                        
                        this.renderCanvas(elements.depthCanvas, depthCanvas);
                        this.renderCanvas(elements.edgesCanvas, edgesCanvas);
                        this.renderCanvas(elements.overlayCanvas, result);
                        this.switchTab('overlay');
                    }
                    
                    const totalTime = performance.now() - startTime;
                    this.updatePerformanceStats(inferenceTime, totalTime);
                    elements.downloadBtn.disabled = false;
                    
                } catch (error) {
                    console.error('Processing error:', error);
                    alert('Error processing image. Please try again.');
                } finally {
                    this.showLoading(false);
                }
            }

            static renderCanvas(canvas, sourceCanvas) {
                const ctx = canvas.getContext('2d');
                canvas.width = sourceCanvas.width;
                canvas.height = sourceCanvas.height;
                ctx.drawImage(sourceCanvas, 0, 0);
            }

            static downloadResult() {
                const activeTab = document.querySelector('.tab-btn.active').dataset.tab;
                const canvas = document.getElementById(`${activeTab}Canvas`);
                
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = `${activeTab}_result.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                }
            }

            static showLoading(show) {
                elements.loadingSpinner.classList.toggle('hidden', !show);
                elements.processBtn.disabled = show;
            }

            static updatePerformanceStats(inferenceTime, totalTime) {
                elements.inferenceTime.textContent = Math.round(inferenceTime);
                elements.totalTime.textContent = Math.round(totalTime);
                elements.perfStats.classList.remove('hidden');
            }

            static toggleDarkMode() {
                document.documentElement.classList.toggle('dark');
                localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
            }

            static loadDarkModePreference() {
                const isDark = localStorage.getItem('darkMode') === 'true';
                if (isDark) {
                    document.documentElement.classList.add('dark');
                }
            }
        }

        // Image Loading
        class ImageLoader {
            static loadFromFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.setCurrentImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            static setCurrentImage(img) {
                currentImage = img;
                
                // Render original image
                const ctx = elements.originalCanvas.getContext('2d');
                elements.originalCanvas.width = img.width;
                elements.originalCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                // Show canvas container
                elements.placeholderText.classList.add('hidden');
                elements.canvasContainer.classList.remove('hidden');
                
                // Enable processing
                elements.processBtn.disabled = false;
                
                // Switch to original tab
                UIManager.switchTab('original');
            }
        }

        // Initialize application
        async function initApp() {
            console.log('Initializing AI Image Processor...');
            
            // Initialize UI
            UIManager.init();
            
            // Load AI models
            try {
                await ImageProcessor.loadModel();
                console.log('Models loaded successfully');
            } catch (error) {
                console.error('Failed to load models:', error);
            }
            
            console.log('Application ready');
        }

        // Wait for OpenCV.js to load
        function onOpenCvReady() {
            console.log('OpenCV.js is ready');
            initApp();
        }

        // Check if OpenCV is already loaded
        if (typeof cv !== 'undefined') {
            onOpenCvReady();
        } else {
            // Wait for OpenCV to load
            setTimeout(() => {
                if (typeof cv !== 'undefined') {
                    onOpenCvReady();
                } else {
                    console.warn('OpenCV.js failed to load, using fallback edge detection');
                    initApp();
                }
            }, 3000);
        }
    </script>
</body>
</html>
